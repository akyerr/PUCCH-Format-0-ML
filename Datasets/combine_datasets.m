clc
clear 
close all

rng('default')

%% Carrier configuration
carrier = nrCarrierConfig;
carrier.SubcarrierSpacing = 30; % 30kHz
carrier.CyclicPrefix = "normal";
carrier.NSizeGrid = 273; % 273 resource blocks = 273*12 = 3276 resource elements (subcarriers)
carrier.NStartGrid = 0;
waveformInfo = nrOFDMInfo(carrier);
% symbolsPerSlot = 13;

%% PUCCH configuration
pucch = nrPUCCH0Config;
pucch.NSizeBWP = 273;
pucch.NStartBWP = 0;
pucch.SymbolAllocation = [12, 1]; % Time allocation
pucch.PRBSet = 0;
pucch.InitialCyclicShift = 0; % m0
pucch.FrequencyHopping = 'neither';

SNRdB = [0, 5, 10, 15, 20];
slot_13_acc = zeros(length(SNRdB), 1);
slot_14_acc = zeros(length(SNRdB), 1);
for s = 1: length(SNRdB)

    SNR = SNRdB(s);

    s13 = load(['pucch_data_slot_13_fading_', num2str(SNR), 'dB_100k.mat']);
    
    s14 = load(['pucch_data_slot_14_fading_', num2str(SNR), 'dB_100k.mat']);
    
    
    X_13 = s13.X; 
    Y_13 = s13.Y;
    
    acc_count_13 = 0;
    for ii = 1: 25000
        pucch_rx = X_13(ii, 1:12) +1i*X_13(ii, 13:24);
        recovered_CS = PUCCH0Decode(carrier, pucch, pucch_rx.', 13);
        if recovered_CS == Y_13(ii, 1)
            acc_count_13 = acc_count_13 + 1;
        end
    end
    slot_13_acc(s) = acc_count_13*100/25000;

    X_14 = s14.X; 
    Y_14 = s14.Y;

    acc_count_14 = 0;
    for ii = 1: 25000
        pucch_rx = X_14(ii, 1:12) +1i*X_14(ii, 13:24);
        recovered_CS = PUCCH0Decode(carrier, pucch, pucch_rx.', 14);
        if recovered_CS == Y_14(ii, 1)
            acc_count_14 = acc_count_14 + 1;
        end
    end
    slot_14_acc(s) = acc_count_14*100/25000;
    
    X0 = [X_13; X_14];
    Y0 = [Y_13; Y_14];
    
    X = zeros(200000, 24); Y = zeros(200000, 1);
    
    rand_ind = randperm(200000).';
    X(:, :) = X0(rand_ind, :);
    Y(:, :) = Y0(rand_ind, :);
    
    save(['./pucch_data_slot_13_14_fading_', num2str(SNR), 'dB_200k.mat'], 'X', 'Y')
end

%% PUCCH decoding of format 0
function recovered_CS = PUCCH0Decode(carrier, pucch, sym, slot)
CP_type = carrier.CyclicPrefix;
hopping_ID = carrier.NCellID;
NSymb = pucch.SymbolAllocation(2);
start_symb = pucch.SymbolAllocation(1);
group_hopping = pucch.GroupHopping;
freq_hopping = pucch.FrequencyHopping;
initial_CS = pucch.InitialCyclicShift;


load_hw_capture = 0;

if load_hw_capture == 1
    in_file = 'pucch_capture.txt';
    rx_uci_seq1 = hextxt2dec(in_file);
    rx_uci_seq2 = hextxt2dec2(in_file);
    check = sum(rx_uci_seq1 - rx_uci_seq2); %#ok
    %
    rx_uci_seq_hw = rx_uci_seq1(1: 12); % only decode 1 symbol
    rx_uci_seq = rx_uci_seq_hw;
else
    rx_uci_seq_matlab = sym(1: 12, 1); % only decode 1 symbol
    rx_uci_seq = rx_uci_seq_matlab;
end

if strcmpi(CP_type, 'normal')
    NSymbSlot = 14;
else
    NSymbSlot = 12;
end

NID = hopping_ID;
v = zeros(1, 2);
fgh = zeros(1, 2);

if strcmpi(group_hopping, 'neither') % No group hopping, no sequence hopping
    %     disp('No group hopping');
    % fgh remains [0, 0]

elseif strcmpi(group_hopping, 'enable') % Group hopping

    cinit = floor(NID/30);

    % If intra slot freq hopping is enabled, nhop = 0 for the first
    % hop and nhop = 1 for the second hop. For the first hop we need
    % c(16*slot+m) and for the second hop we need c(16*slot+8+m).
    % Where m = 0 to 7. This means we need 16 elements in total from
    % the pseudo random seq c.

    % If intra slot freq hopping is disabled, nhop is 0. But we assume
    % that hopping is enabled and generate parameters for both hops.
    % Later we decide which ones are needed.

    % First we will extract the required elements from c. In the second
    % argument [8*2*slot, 16], 8*2*slot indicates where we start extracting
    % from. 16 indicates how many elements we extract.

    c = pseudorandom_sequence(cinit, [8*2*slot, 16]);

    % reshape (c, 8, []) fixes 8 rows and then however many columns
    % that are needed to fit all the elements. We have 16 elements
    % extracted from c. The first 8 belong to the first hop. The next 8
    % belong to the second hop. The reshape results in 2 columns. The
    % first 8 elements for the first hop in col 1 and the next 8 in col
    % 2. Then weighted sum each column with powers of 2.
    fgh(1,:) = mod((2.^(0:7))*reshape(c, 8, []), 30);

else % sequence hopping

    % if group hopping is disabled, sequence hopping is enabled within
    % the group.
    cinit = 32*floor(NID/30) + mod(NID,30);

    % If intra slot freq hopping is disabled, nhop is 0. But we assume
    % that hopping is enabled and generate parameters for both hops.
    % Later we decide which ones are needed.

    % First we will extract the required elements from c. In the second
    % argument [2*slot, 2], 2*slot indicates where we start extracting
    % from. 2 indicates how many elements we extract.

    c = pseudorandom_sequence(cinit, [2*slot, 2]);

    v(1,:) = double(c');
end

% Sequence shift offset Mod 30 because there are 30 groups (0 to 29)
% This is for all cases. group hopping enable, disable and neither
fss = mod(NID,30);

% Group numbers. First element: first hop in the slot. Second
% element: second hop in the slot (0 to 29)
u = mod(fgh+fss,30);


c0 = nrPRBS(NID, [NSymbSlot*8*slot, NSymbSlot*8]);


c = pseudorandom_sequence(NID, [NSymbSlot*8*slot, NSymbSlot*8]);

check = sum(xor(c0, c));
% Get the value of ncs for all the symbols in a slot
ncs = (2.^(0:7))*reshape(c, 8, []);

% Get the cyclic shift for all the symbols in a slot
% 12 is the number of REs per resource block
m0 = initial_CS;
m11_0 = mod(m0 + ncs, 12); % for all 14 symbols

% extract cyclic shifts only for the PUCCH symbols in the slot
m11 = m11_0(start_symb+1: start_symb+NSymb)+1;

base_seq = low_papr_seq(u, v, 12);

base_seq_symb1 = base_seq(:, 1);


x = rx_uci_seq;
y = base_seq_symb1;

[~, ind] = max(abs(fft(x.*conj(y))));

recovered_CS = mod((ind - m11(1)), 12);

% uci = nrPUCCHDecode(carrier,pucch,[1 0],rx_uci_seq1);
dbg = 1;
end

%% Low PAPR Seq
function base_seq = low_papr_seq(u, v, m)
for vid = 1: length(v)
    for uid = 1: length(u)
        %         nIndex = (0: m-1)';
        phi = getPhiType1(u(uid), m);
        base_seq0 = exp(1j.*phi.*pi/4);
    end
end

base_seq = repmat(base_seq0, 1 , length(u));
end

%% Phi
function phi = getPhiType1(u,m)
%   PHI = getPhiType1(U,M) provides the phase values, PHI, to be applied
%   for generating the type 1 base sequence based on the group number U and
%   the sequence length M, as stated in the TS 38.211 Section 5.2.2.

% Get the table of phase values based on the length M
if m == 6 % Table 5.2.2.2-1
    phiTable = [-3  -1   3   3  -1  -3; ...
        -3   3  -1  -1   3  -3; ...
        -3  -3  -3   3   1  -3; ...
        1   1   1   3  -1  -3; ...
        1   1   1  -3  -1   3; ...
        -3   1  -1  -3  -3  -3; ...
        -3   1   3  -3  -3  -3; ...
        -3  -1   1  -3   1  -1; ...
        -3  -1  -3   1  -3  -3; ...
        -3  -3   1  -3   3  -3; ...
        -3   1   3   1  -3  -3; ...
        -3  -1  -3   1   1  -3; ...
        1   1   3  -1  -3   3; ...
        1   1   3   3  -1   3; ...
        1   1   1  -3   3  -1; ...
        1   1   1  -1   3  -3; ...
        -3  -1  -1  -1   3  -1; ...
        -3  -3  -1   1  -1  -3; ...
        -3  -3  -3   1  -3  -1; ...
        -3   1   1  -3  -1  -3; ...
        -3   3  -3   1   1  -3; ...
        -3   1  -3  -3  -3  -1; ...
        1   1  -3   3   1   3; ...
        1   1  -3  -3   1  -3; ...
        1   1   3  -1   3   3; ...
        1   1  -3   1   3   3; ...
        1   1  -1  -1   3  -1; ...
        1   1  -1   3  -1  -1; ...
        1   1  -1   3  -3  -1; ...
        1   1  -3   1  -1  -1];
elseif m == 12 % Table 5.2.2.2-2
    phiTable = [-3   1  -3  -3  -3   3  -3  -1   1   1   1  -3; ...
        -3   3   1  -3   1   3  -1  -1   1   3   3   3; ...
        -3   3   3   1  -3   3  -1   1   3  -3   3  -3; ...
        -3  -3  -1   3   3   3  -3   3  -3   1  -1  -3; ...
        -3  -1  -1   1   3   1   1  -1   1  -1  -3   1; ...
        -3  -3   3   1  -3  -3  -3  -1   3  -1   1   3; ...
        1  -1   3  -1  -1  -1  -3  -1   1   1   1  -3; ...
        -1  -3   3  -1  -3  -3  -3  -1   1  -1   1  -3; ...
        -3  -1   3   1  -3  -1  -3   3   1   3   3   1; ...
        -3  -1  -1  -3  -3  -1  -3   3   1   3  -1  -3; ...
        -3   3  -3   3   3  -3  -1  -1   3   3   1  -3; ...
        -3  -1  -3  -1  -1  -3   3   3  -1  -1   1  -3; ...
        -3  -1   3  -3  -3  -1  -3   1  -1  -3   3   3; ...
        -3   1  -1  -1   3   3  -3  -1  -1  -3  -1  -3; ...
        1   3  -3   1   3   3   3   1  -1   1  -1   3; ...
        -3   1   3  -1  -1  -3  -3  -1  -1   3   1  -3; ...
        -1  -1  -1  -1   1  -3  -1   3   3  -1  -3   1; ...
        -1   1   1  -1   1   3   3  -1  -1  -3   1  -3; ...
        -3   1   3   3  -1  -1  -3   3   3  -3   3  -3; ...
        -3  -3   3  -3  -1   3   3   3  -1  -3   1  -3; ...
        3   1   3   1   3  -3  -1   1   3   1  -1  -3; ...
        -3   3   1   3  -3   1   1   1   1   3  -3   3; ...
        -3   3   3   3  -1  -3  -3  -1  -3   1   3  -3; ...
        3  -1  -3   3  -3  -1   3   3   3  -3  -1  -3; ...
        -3  -1   1  -3   1   3   3   3  -1  -3   3   3; ...
        -3   3   1  -1   3   3  -3   1  -1   1  -1   1; ...
        -1   1   3  -3   1  -1   1  -1  -1  -3   1  -1; ...
        -3  -3   3   3   3  -3  -1   1  -3   3   1  -3; ...
        1  -1   3   1   1  -1  -1  -1   1   3  -3   1; ...
        -3   3  -3   3  -3  -3   3  -1  -1   1   3  -3];
elseif m == 18 % Table 5.2.2.2-3
    phiTable = [-1   3  -1  -3   3   1  -3  -1   3  -3  -1  -1   1   1   1  -1  -1  -1; ...
        3  -3   3  -1   1   3  -3  -1  -3  -3  -1  -3   3   1  -1   3  -3   3; ...
        -3   3   1  -1  -1   3  -3  -1   1   1   1   1   1  -1   3  -1  -3  -1; ...
        -3  -3   3   3   3   1  -3   1   3   3   1  -3  -3   3  -1  -3  -1   1; ...
        1   1  -1  -1  -3  -1   1  -3  -3  -3   1  -3  -1  -1   1  -1   3   1; ...
        3  -3   1   1   3  -1   1  -1  -1  -3   1   1  -1   3   3  -3   3  -1; ...
        -3   3  -1   1   3   1  -3  -1   1   1  -3   1   3   3  -1  -3  -3  -3; ...
        1   1  -3   3   3   1   3  -3   3  -1   1   1  -1   1  -3  -3  -1   3; ...
        -3   1  -3  -3   1  -3  -3   3   1  -3  -1  -3  -3  -3  -1   1   1   3; ...
        3  -1   3   1  -3  -3  -1   1  -3  -3   3   3   3   1   3  -3   3  -3; ...
        -3  -3  -3   1  -3   3   1   1   3  -3  -3   1   3  -1   3  -3  -3   3; ...
        -3  -3   3   3   3  -1  -1  -3  -1  -1  -1   3   1  -3  -3  -1   3  -1; ...
        -3  -1  -3  -3   1   1  -1  -3  -1  -3  -1  -1   3   3  -1   3   1   3; ...
        1   1  -3  -3  -3  -3   1   3  -3   3   3   1  -3  -1   3  -1  -3   1; ...
        -3   3  -1  -3  -1  -3   1   1  -3  -3  -1  -1   3  -3   1   3   1   1; ...
        3   1  -3   1  -3   3   3  -1  -3  -3  -1  -3  -3   3  -3  -1   1   3; ...
        -3  -1  -3  -1  -3   1   3  -3  -1   3   3   3   1  -1  -3   3  -1  -3; ...
        -3  -1   3   3  -1   3  -1  -3  -1   1  -1  -3  -1  -1  -1   3   3   1; ...
        -3   1  -3  -1  -1   3   1  -3  -3  -3  -1  -3  -3   1   1   1  -1  -1; ...
        3   3   3  -3  -1  -3  -1   3  -1   1  -1  -3   1  -3  -3  -1   3   3; ...
        -3   1   1  -3   1   1   3  -3  -1  -3  -1   3  -3   3  -1  -1  -1  -3; ...
        1  -3  -1  -3   3   3  -1  -3   1  -3  -3  -1  -3  -1   1   3   3   3; ...
        -3  -3   1  -1  -1   1   1  -3  -1   3   3   3   3  -1   3   1   3   1; ...
        3  -1  -3   1  -3  -3  -3   3   3  -1   1  -3  -1   3   1   1   3   3; ...
        3  -1  -1   1  -3  -1  -3  -1  -3  -3  -1  -3   1   1   1  -3  -3   3; ...
        -3  -3   1  -3   3   3   3  -1   3   1   1  -3  -3  -3   3  -3  -1  -1; ...
        -3  -1  -1  -3   1  -3   3  -1  -1  -3   3   3  -3  -1   3  -1  -1  -1; ...
        -3  -3   3   3  -3   1   3  -1  -3   1  -1  -3   3  -3  -1  -1  -1   3; ...
        -1  -3   1  -3  -3  -3   1   1   3   3  -3   3   3  -3  -1   3  -3   1; ...
        -3   3   1  -1  -1  -1  -1   1  -1   3   3  -3  -1   1   3  -1   3  -1];
else % m is equal to 24. Table 5.2.2.2-4
    phiTable = [-1  -3   3  -1   3   1   3  -1   1  -3  -1  -3  -1   1   3  -3  -1  -3   3   3   3  -3  -3  -3; ...
        -1  -3   3   1   1  -3   1  -3  -3   1  -3  -1  -1   3  -3   3   3   3  -3   1   3   3  -3  -3; ...
        -1  -3  -3   1  -1  -1  -3   1   3  -1  -3  -1  -1  -3   1   1   3   1  -3  -1  -1   3  -3  -3; ...
        1  -3   3  -1  -3  -1   3   3   1  -1   1   1   3  -3  -1  -3  -3  -3  -1   3  -3  -1  -3  -3; ...
        -1   3  -3  -3  -1   3  -1  -1   1   3   1   3  -1  -1  -3   1   3   1  -1  -3   1  -1  -3  -3; ...
        -3  -1   1  -3  -3   1   1  -3   3  -1  -1  -3   1   3   1  -1  -3  -1  -3   1  -3  -3  -3  -3; ...
        -3   3   1   3  -1   1  -3   1  -3   1  -1  -3  -1  -3  -3  -3  -3  -1  -1  -1   1   1  -3  -3; ...
        -3   1   3  -1   1  -1   3  -3   3  -1  -3  -1  -3   3  -1  -1  -1  -3  -1  -1  -3   3   3  -3; ...
        -3   1  -3   3  -1  -1  -1  -3   3   1  -1  -3  -1   1   3  -1   1  -1   1  -3  -3  -3  -3  -3; ...
        1   1  -1  -3  -1   1   1  -3   1  -1   1  -3   3  -3  -3   3  -1  -3   1   3  -3   1  -3  -3; ...
        -3  -3  -3  -1   3  -3   3   1   3   1  -3  -1  -1  -3   1   1   3   1  -1  -3   3   1   3  -3; ...
        -3   3  -1   3   1  -1  -1  -1   3   3   1   1   1   3   3   1  -3  -3  -1   1  -3   1   3  -3; ...
        3  -3   3  -1  -3   1   3   1  -1  -1  -3  -1   3  -3   3  -1  -1   3   3  -3  -3   3  -3  -3; ...
        -3   3  -1   3  -1   3   3   1   1  -3   1   3  -3   3  -3  -3  -1   1   3  -3  -1  -1  -3  -3; ...
        -3   1  -3  -1  -1   3   1   3  -3   1  -1   3   3  -1  -3   3  -3  -1  -1  -3  -3  -3   3  -3; ...
        -3  -1  -1  -3   1  -3  -3  -1  -1   3  -1   1  -1   3   1  -3  -1   3   1   1  -1  -1  -3  -3; ...
        -3  -3   1  -1   3   3  -3  -1   1  -1  -1   1   1  -1  -1   3  -3   1  -3   1  -1  -1  -1  -3; ...
        3  -1   3  -1   1  -3   1   1  -3  -3   3  -3  -1  -1  -1  -1  -1  -3  -3  -1   1   1  -3  -3; ...
        -3   1  -3   1  -3  -3   1  -3   1  -3  -3  -3  -3  -3   1  -3  -3   1   1  -3   1   1  -3  -3; ...
        -3  -3   3   3   1  -1  -1  -1   1  -3  -1   1  -1   3  -3  -1  -3  -1  -1   1  -3   3  -1  -3; ...
        -3  -3  -1  -1  -1  -3   1  -1  -3  -1   3  -3   1  -3   3  -3   3   3   1  -1  -1   1  -3  -3; ...
        3  -1   1  -1   3  -3   1   1   3  -1  -3   3   1  -3   3  -1  -1  -1  -1   1  -3  -3  -3  -3; ...
        -3   1  -3   3  -3   1  -3   3   1  -1  -3  -1  -3  -3  -3  -3   1   3  -1   1   3   3   3  -3; ...
        -3  -1   1  -3  -1  -1   1   1   1   3   3  -1   1  -1   1  -1  -1  -3  -3  -3   3   1  -1  -3; ...
        -3   3  -1  -3  -1  -1  -1   3  -1  -1   3  -3  -1   3  -3   3  -3  -1   3   1   1  -1  -3  -3; ...
        -3   1  -1  -3  -3  -1   1  -3  -1  -3   1   1  -1   1   1   3   3   3  -1   1  -1   1  -1  -3; ...
        -1   3  -1  -1   3   3  -1  -1  -1   3  -1  -3   1   3   1   1  -3  -3  -3  -1  -3  -1  -3  -3; ...
        3  -3  -3  -1   3   3  -3  -1   3   1   1   1   3  -1   3  -3  -1   3  -1   3   1  -1  -3  -3; ...
        -3   1  -3   1  -3   1   1   3   1  -3  -3  -1   1   3  -1  -3   3   1  -1  -3  -3  -3  -3  -3; ...
        3  -3  -1   1   3  -1  -1  -3  -1   3  -1  -3  -1  -3   3  -1   3   1   1  -3   3  -3  -3  -3];
end

% Get the phase values specific to group number u from the table of
% phase values
phi = phiTable(u+1,:)';

end
